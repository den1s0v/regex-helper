<!DOCTYPE html>
<!-- saved from url=(0039)https://codemirror.net/1/contrib/regex/ -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Regex Writing Helper</title>
<script type="text/javascript" src="lib/codemirror.js"></script>
<script type="text/javascript" src="js/replacer.js"></script>
<link rel="stylesheet" href="lib/codemirror.css">
<!-- <link rel="stylesheet" href="lib/eclipse.css"> -->
<style type="text/css" media="screen">
    .string { color: #555; font-style: italic }
    .atom { color: #f08; font-style: italic; font-weight: bold; }
    .comment { color: #262; font-style: italic; line-height: 1em; }
    .meta { color: #555; font-style: italic; line-height: 1em; }
    .variable { color: #700; text-decoration: underline; }
    .variable-2 { color: #b11; }
    .struct { color: #07c; font-weight: bold; }
    .number { color: #f00; font-weight: bold; font-style: normal; }
    .program { color: #f70; font-weight: bold; }
    .function { color: #707; font-weight: bold; }
    .action { color: #077; font-weight: bold; }
    .qualifier { color: #555; }
    .keyword { color: #00a; font-weight: bold; }
    .builtin { color: #30a; }
    .link { color: #762; }
    .value { color: #0aa; font-weight: bold; font-style: normal; }
    .plain { color: #000; font-weight: normal; font-style: normal; }

    .warning { background-color: #ff9; }
    .error { background-color: #fdd; }
    .button { background-color: #add; }

    /* based on https://pyformat.info/ */
    .separated-text {
        display: inline-block;
        margin-right: 1px;
        padding: 0 2px;
        background: #ececec;
        /* + mine: */
        text-decoration: underline; 
    }
    .char {
        display: inline-block;
        /* margin-right: 1px;
        padding: 0 2px; */
        background: #ececec;
        /* + mine: */
        /* text-decoration: underline;  */
    }

    .circle
    {
        /* background: #cbcbcb; */
        background: radial-gradient(circle at center,  #adacac81 0%,#adacac81 29%,#adacac81 29%,#00000000 29%,#90ecfe00 35%);
        position: relative;
        top: 1px;  /* смещение вниз */
    }

    .editor {
        border-radius: 5px;
        border: 3px solid #18069e;
    }
   
    .editor.src {
        border-radius: 3px;
        border: 7px solid #071ffa;
    }
   
    .editor.dst {
        border-radius: 3px;
        border: 7px solid #07fa0b;
    }
   
    .button-active {
        border: 2px solid rgb(255, 0, 0);
        color: rgb(3, 164, 3);
    }
   
</style>
<script type="text/javascript">

window.onload = function () {
    // let cm = CodeMirror.fromTextArea('regexp');
    let cm_a = CodeMirror.fromTextArea(document.getElementById('cm_a'), {
        lineWrapping: true,
        scrollbarStyle: null,
        // lineNumbers: true,
        // theme: 'eclipse',
    });
    cm_a.setSize(null, 50);  // width, height

    let cm_b = CodeMirror.fromTextArea(document.getElementById('cm_b'), {
        lineWrapping: true,
        scrollbarStyle: null,
    });
    cm_b.setSize(null, 50);  // width, height
    
    let cm_config = CodeMirror.fromTextArea(document.getElementById('cm_config'), {
        lineWrapping: false,
        lineNumbers: true,
        // scrollbarStyle: null,
    });


    // https://discuss.codemirror.net/t/single-line-codemirror/195/3
    // a solution to prevent new lines (its for a custom search query input field):
    function suppress_newlines(cm, changeObj) {
        var typedNewLine = changeObj.origin == '+input' && typeof changeObj.text == "object" && changeObj.text.join("") == "";
        if (typedNewLine) {
            return changeObj.cancel();
        }

        var pastedNewLine = changeObj.origin == 'paste' && typeof changeObj.text == "object" && changeObj.text.length > 1;
        if (pastedNewLine) {
            var newText = changeObj.text.join(" ");

            // trim
            //newText = $.trim(newText);

            return changeObj.update(null, null, [newText]);
        }

        return null;
    }
    cm_a.on("beforeChange", suppress_newlines);
    cm_b.on("beforeChange", suppress_newlines);

    function set_remove_class(elem, new_class, old_class=null) {
        if (old_class /* && elem */ && elem.classList.contains(old_class)) {
            elem.classList.remove(old_class);
        }
        if (new_class && !elem.classList.contains(old_class)) {
            elem.classList.add(new_class);
        }
    }
    function update_direction_indication(mode = null) {
        if (mode === 'a-b') {
            set_remove_class(document.getElementById('cm_a_area'), 'src', 'dst');
            set_remove_class(document.getElementById('cm_b_area'), 'dst', 'src');
            set_remove_class(document.getElementById('btn-go-ab'), 'button-active', null);
            set_remove_class(document.getElementById('btn-go-ba'), null, 'button-active');
        } else if (mode === 'b-a') {
            set_remove_class(document.getElementById('cm_b_area'), 'src', 'dst');
            set_remove_class(document.getElementById('cm_a_area'), 'dst', 'src');
            set_remove_class(document.getElementById('btn-go-ba'), 'button-active', null);
            set_remove_class(document.getElementById('btn-go-ab'), null, 'button-active');
        } else {
            set_remove_class(document.getElementById('cm_a_area'), null, 'src');
            set_remove_class(document.getElementById('cm_b_area'), null, 'src');
            set_remove_class(document.getElementById('btn-go-ab'), null, 'button-active');
            set_remove_class(document.getElementById('btn-go-ba'), null, 'button-active');
        }
    }

    let need_update_a = true;
    let need_update_b = true;

    cm_a.on("changes", function(cm, _changes) {
        if (!need_update_a) return;  // prevent infinite loop of updates
        go('a-b');
    })
    
    cm_b.on("changes", function(cm, _changes) {
        if (!need_update_b) return;  // prevent infinite loop of updates
        go('b-a');
    })

    document.getElementById("btn-go-ab").addEventListener('click', () => go('a-b'));
    document.getElementById("btn-go-ba").addEventListener('click', () => go('b-a'));

    cm_config.on("changes", function(cm, _changes) {
        go('none');
    })

    // main UI-event-entry function
    function go(direction = 'a-b') {
        if (direction === 'a-b') {
            need_update_b = false;
            do_replace(cm_a, cm_b, direction);
            need_update_b = true;
        } else if (direction === 'b-a') {
            need_update_a = false;
            do_replace(cm_b, cm_a, direction);
            need_update_a = true;
        }
        update_direction_indication(direction);
    }

    function do_replace(cm_src, cm_dst, direction = 'a-b') {
        

        let replace_items = parse_replacement_config(direction === 'b-a');

        let rr = new Replacer(replace_items);

        let [result, matches] = rr.replace_in_string(cm_src.getValue());

        cm_dst.setValue(result);

        // hightlight ...
        //// console.log('matches:', matches)
        update_marks(matches, direction);
    }

    function update_marks(matches, direction = 'a-b') {
        /// ...
        cm_a.getAllMarks().forEach(m => m.clear());
        cm_b.getAllMarks().forEach(m => m.clear());
        cm_config.getAllMarks().forEach(m => m.clear());

        let cm_role_list = (direction === 'a-b')? [[cm_a, 'src'], [cm_b, 'dst']] : [[cm_b, 'src'], [cm_a, 'dst']];
        // cm_role_list.reverse(); ///

        matches.forEach(m => {
            for (cm_role of cm_role_list) {
                let [cm, role] = cm_role;
                let css_class = 'char';
                let mark_each_char = false;

                const cm_positions = m.locationForMark(role);
                let highlighted_text = cm.getRange(...cm_positions);
                if (highlighted_text.trim() === '') {
                    // spaces only (note than \n is impossible in current setting)
                    css_class = 'circle';
                    mark_each_char = true;
                }
                const mark_options = {
                    // css: m.ri.style,
                    className: css_class,
                };

                if (mark_each_char) {
                    const line = cm_positions[0].line;
                    for (let i = cm_positions[0].ch; i < cm_positions[1].ch; i++)
                        cm.markText({line, ch: i}, {line, ch: i + 1}, mark_options);
                } else {
                    // let params = [...cm_positions, mark_options ];
                    // console.log('mark:', params) ///
                    cm.markText(...cm_positions, mark_options);
                }

            }
        });
    }

    function parse_replacement_config(inversed = false) {
        let lines = str_strip(cm_config.getValue()).split('\n');
        if (inversed) {
            lines.reverse(); // bottom-to-top order in reverse mode
        }
        let replace_items = [];
        for (line of lines) {
            let ri = ReplaceItem.fromStr(line, inversed);
            if (ri === false) {
                console.log('Syntax error in line: ', line);
            }
            if (ri) {
                replace_items.push(ri);
            }
        }
        return replace_items;
    }

    function make_some_fun() {

        cm_a.setSelection(/* anchor: */ {line: 0, ch: 10}, /* ?head: */ {line: 0, ch: 20});

        // Вставка
        cm_a.replaceRange(/* replacement: */ ' (и мне)', /* from: */ {line: 0, ch: 56}, /* to: */ {line: 0, ch: 56});

        cm_a.markText(/* from: */ {line: 0, ch: 26}, /* to: */ {line: 0, ch: 46}, /* ?options: */ {
            className: 'atom',
        });
        
        cm_a.markText(/* from: */ {line: 0, ch: 58}, /* to: */ {line: 0, ch: 86}, /* ?options: */ {
            className: 'keyword',
        });
        
        cm_a.markText(/* from: */ {line: 0, ch: 98}, /* to: */ {line: 0, ch: 106}, /* ?options: */ {
            className: 'variable',
        });
        
        for (let i = 108; i < 134; i++) {
            cm_a.markText(/* from: */ {line: 0, ch: i}, /* to: */ {line: 0, ch: i + 1}, /* ?options: */ {
                className: 'separated-text',
            });
        }


        /***- Fun)) -***/
        // clear all marks
        function removeRandomMark() {
            let ms = cm_a.getAllMarks();
            if (ms.length == 0) {
                clearInterval(interval);
                return;
            }

            let m = ms[parseInt(Math.random() * ms.length)];
            m.clear();
        }
        setTimeout(() => {cm_a.getAllMarks().forEach(m => m.clear())}, 6500);
        let interval = setInterval(removeRandomMark, 200);
    }


};

</script>
</head>

<body>
<div>
    <h1>Regex Writing Helper</h1>
        <details open>
            <summary>Описание (нажмите здесь, чтобы свернуть)</summary>
        <p>
            Появилась идея сделать regex-helper для помощи при составлении регулярок для Степика. <!-- (опять же, на JS без сервера, и опубликовать ли его либо на github pages, либо на replit) -->
        </p>
        <p>
            Проблема:  регулярки быстро становится длинными и плохо читаются.
            Например:
            <ul>
                <li>Там, где может стоять необязательный пробел, нужно написать <span class="separated-text">\s*</span> </li>
                <li>Там, где должен стоять 1 пробел или более, нужно написать <span class="separated-text">\s+</span> </li>
                <li>Там, где должны стоять (круглые / фигурные / квадратные) скобки, их нужно экранировать. </li>
                <li>Символы арифметики, точку и некоторые другие символы нужно экранировать в соответствии с синтаксисом регулярок. </li>
            </ul>
        </p>
        <p>
            Решение: заменять частые фрагменты автоматически, не ухудшая читаемости.  Условимся, что:
            <ul>
                <li><big><span class="separated-text">\s*</span> — пробел не нужен, но <b>допустим</b> — будем обозначать <b>одиночным пробелом</b>,</big> </li>
                <li><big><span class="separated-text">\s+</span> — пробел <b>нужен</b>, хотя бы один — будем обозначать <b>двойным пробелом</b>,</big> </li>
                <li>Отдельные спецсимволы (<span class="separated-text">+ * / ( ) [ ] { }</span>) будем экранировать одинарным обратным слешем (<span class="separated-text">\</span>) </li>
                <li>Сам обратный слеш (<span class="separated-text">\</span>) заменять не будем, сохраняя спецпоследовательности, заданные в верхнем поле вручную. </li>
            </ul>

            <small>
                Полученную в нижнем поле регулярку можно проверить сервисом <a href="https://regex101.com/">regex101.com</a> и использовать на Степике.
            </small>

        </p>
        </details>

        <h3>Редактор (условный язык) и заменённый текст (сформированная регулярка)</h3>

        <div class="editor src" id="cm_a_area">
            <textarea id="cm_a" cols="100" rows="1" >int  my_func ( int  param1 , float  param2 ) ;</textarea>
        </div>

        <input type="button" id="btn-go-ab" value="▼" title="применить замены к верхнему полю" style="font-size : 30px; width: 95px ; height: 35px; margin-left: 10%;">
        <input type="button" id="btn-go-ba" value="▲"  title="применить замены в обратном направлении к нижнему полю"  style="font-size : 30px; width: 95px ; height: 35px;">
            
        <div class="editor dst" id="cm_b_area">
            <textarea id="cm_b" cols="100" rows="1" > -- Результат --</textarea>
        </div>

        <h3>Настройка замен</h3>
            
        <div class="editor" id="cm_config_area">
            <textarea id="cm_config" cols="100" rows="30" >// Перечень замен (можно изменять!) ... 
' '  -> \s*     // Один пробел становится "опциональным пробелом"
"  " -> \s+     // Два пробела становятся "минимум одним пробелом"
+    -> \+  
+    -> \+
*    -> \*      // (остальные символы просто экранируются обратным слешем)
/    -> \/
(    -> \(
)    -> \)
[    -> \[
]    -> \]
{    -> \{
}    -> \}
            </textarea>
        </div>
            
<!-- <div class="CodeMirror-wrapping" style="position: relative; height: 84px;"><textarea tabindex="100000" style="position: absolute; left: -10000px; width: 10px;"></textarea><iframe frameborder="0" src="javascript:;" style="border: 0px; width: 100%; height: 100%; display: block;" scrolling="no" src="js/saved_resource.html"></iframe></div> -->
</div>


</body></html>